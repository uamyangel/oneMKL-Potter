// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: LogicalNetlist.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>

#if CAPNP_VERSION != 9001
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif

#include "References.capnp.h"

CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(f5e87659c5d1baaa);
CAPNP_DECLARE_SCHEMA(a21c701a5b5b31d7);
CAPNP_DECLARE_SCHEMA(fe08a36900b7aef1);
CAPNP_DECLARE_SCHEMA(81048c9d2a1084e5);
CAPNP_DECLARE_SCHEMA(cebd5deb07a1e8d0);
CAPNP_DECLARE_SCHEMA(a8788af96fe62735);
CAPNP_DECLARE_SCHEMA(d5c073f0cfa35210);
CAPNP_DECLARE_SCHEMA(bd5b42f5c77a55df);
CAPNP_DECLARE_SCHEMA(aba131b7aa3363af);
CAPNP_DECLARE_SCHEMA(ffb3379db6b5d8c1);
CAPNP_DECLARE_SCHEMA(e47e4296fd6bbdb1);
CAPNP_DECLARE_SCHEMA(e51459a76fc8efd5);
CAPNP_DECLARE_SCHEMA(b2700fad50494562);
CAPNP_DECLARE_SCHEMA(fa10639436a3129d);
CAPNP_DECLARE_SCHEMA(eb33ec79cf6126b0);
CAPNP_DECLARE_SCHEMA(9f8b1db7705dc45b);
CAPNP_DECLARE_SCHEMA(9c2d93e04cfa4ca7);
enum class Direction_9c2d93e04cfa4ca7: uint16_t {
  INPUT,
  OUTPUT,
  INOUT,
};
CAPNP_DECLARE_ENUM(Direction, 9c2d93e04cfa4ca7);
CAPNP_DECLARE_SCHEMA(99de7c18c40ca186);
CAPNP_DECLARE_SCHEMA(bb789fd3bdf57009);
CAPNP_DECLARE_SCHEMA(ef2ee5ca8eaab043);
CAPNP_DECLARE_SCHEMA(c10e1f074e7137d2);
CAPNP_DECLARE_SCHEMA(c62857fbbda36438);
CAPNP_DECLARE_SCHEMA(d215f9e48951933d);

}  // namespace schemas
}  // namespace capnp

namespace LogicalNetlist {

struct HashSet {
  HashSet() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f5e87659c5d1baaa, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct StringRef {
  StringRef() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fe08a36900b7aef1, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct PortRef {
  PortRef() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cebd5deb07a1e8d0, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CellRef {
  CellRef() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d5c073f0cfa35210, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct InstRef {
  InstRef() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(aba131b7aa3363af, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Netlist {
  Netlist() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct CellDeclaration;
  struct CellInstance;
  struct Cell;
  struct Net;
  struct Port;
  typedef ::capnp::schemas::Direction_9c2d93e04cfa4ca7 Direction;

  struct Bus;
  struct PortInstance;
  struct Bitstring;
  struct PropertyMap;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e47e4296fd6bbdb1, 0, 8)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Netlist::CellDeclaration {
  CellDeclaration() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e51459a76fc8efd5, 2, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Netlist::CellInstance {
  CellInstance() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b2700fad50494562, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Netlist::Cell {
  Cell() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fa10639436a3129d, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Netlist::Net {
  Net() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(eb33ec79cf6126b0, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Netlist::Port {
  Port() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    BIT,
    BUS,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9f8b1db7705dc45b, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Netlist::Bus {
  Bus() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(99de7c18c40ca186, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Netlist::PortInstance {
  PortInstance() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    EXT_PORT,
    INST,
  };
  struct BusIdx;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bb789fd3bdf57009, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Netlist::PortInstance::BusIdx {
  BusIdx() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    SINGLE_BIT,
    IDX,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ef2ee5ca8eaab043, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Netlist::Bitstring {
  Bitstring() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c10e1f074e7137d2, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Netlist::PropertyMap {
  PropertyMap() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct Entry;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c62857fbbda36438, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Netlist::PropertyMap::Entry {
  Entry() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    TEXT_VALUE,
    INT_VALUE,
    BOOL_VALUE,
    BITSTRING_VALUE,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d215f9e48951933d, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class HashSet::Reader {
public:
  typedef HashSet Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::ImplementationType getType() const;

  inline bool getHide() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class HashSet::Builder {
public:
  typedef HashSet Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::ImplementationType getType();
  inline void setType( ::ImplementationType value);

  inline bool getHide();
  inline void setHide(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class HashSet::Pipeline {
public:
  typedef HashSet Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class StringRef::Reader {
public:
  typedef StringRef Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::ReferenceType getType() const;

  inline bool hasField() const;
  inline  ::capnp::Text::Reader getField() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class StringRef::Builder {
public:
  typedef StringRef Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::ReferenceType getType();
  inline void setType( ::ReferenceType value);

  inline bool hasField();
  inline  ::capnp::Text::Builder getField();
  inline void setField( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initField(unsigned int size);
  inline void adoptField(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownField();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class StringRef::Pipeline {
public:
  typedef StringRef Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class PortRef::Reader {
public:
  typedef PortRef Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::ReferenceType getType() const;

  inline bool hasField() const;
  inline  ::capnp::Text::Reader getField() const;

  inline  ::int32_t getDepth() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PortRef::Builder {
public:
  typedef PortRef Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::ReferenceType getType();
  inline void setType( ::ReferenceType value);

  inline bool hasField();
  inline  ::capnp::Text::Builder getField();
  inline void setField( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initField(unsigned int size);
  inline void adoptField(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownField();

  inline  ::int32_t getDepth();
  inline void setDepth( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PortRef::Pipeline {
public:
  typedef PortRef Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CellRef::Reader {
public:
  typedef CellRef Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::ReferenceType getType() const;

  inline bool hasField() const;
  inline  ::capnp::Text::Reader getField() const;

  inline  ::int32_t getDepth() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CellRef::Builder {
public:
  typedef CellRef Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::ReferenceType getType();
  inline void setType( ::ReferenceType value);

  inline bool hasField();
  inline  ::capnp::Text::Builder getField();
  inline void setField( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initField(unsigned int size);
  inline void adoptField(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownField();

  inline  ::int32_t getDepth();
  inline void setDepth( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CellRef::Pipeline {
public:
  typedef CellRef Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class InstRef::Reader {
public:
  typedef InstRef Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::ReferenceType getType() const;

  inline bool hasField() const;
  inline  ::capnp::Text::Reader getField() const;

  inline  ::int32_t getDepth() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class InstRef::Builder {
public:
  typedef InstRef Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::ReferenceType getType();
  inline void setType( ::ReferenceType value);

  inline bool hasField();
  inline  ::capnp::Text::Builder getField();
  inline void setField( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initField(unsigned int size);
  inline void adoptField(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownField();

  inline  ::int32_t getDepth();
  inline void setDepth( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class InstRef::Pipeline {
public:
  typedef InstRef Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Netlist::Reader {
public:
  typedef Netlist Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline bool hasPropMap() const;
  inline  ::LogicalNetlist::Netlist::PropertyMap::Reader getPropMap() const;

  inline bool hasStrList() const;
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader getStrList() const;

  inline bool hasPortList() const;
  inline  ::capnp::List< ::LogicalNetlist::Netlist::Port,  ::capnp::Kind::STRUCT>::Reader getPortList() const;

  inline bool hasCellDecls() const;
  inline  ::capnp::List< ::LogicalNetlist::Netlist::CellDeclaration,  ::capnp::Kind::STRUCT>::Reader getCellDecls() const;

  inline bool hasTopInst() const;
  inline  ::LogicalNetlist::Netlist::CellInstance::Reader getTopInst() const;

  inline bool hasInstList() const;
  inline  ::capnp::List< ::LogicalNetlist::Netlist::CellInstance,  ::capnp::Kind::STRUCT>::Reader getInstList() const;

  inline bool hasCellList() const;
  inline  ::capnp::List< ::LogicalNetlist::Netlist::Cell,  ::capnp::Kind::STRUCT>::Reader getCellList() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Netlist::Builder {
public:
  typedef Netlist Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline bool hasPropMap();
  inline  ::LogicalNetlist::Netlist::PropertyMap::Builder getPropMap();
  inline void setPropMap( ::LogicalNetlist::Netlist::PropertyMap::Reader value);
  inline  ::LogicalNetlist::Netlist::PropertyMap::Builder initPropMap();
  inline void adoptPropMap(::capnp::Orphan< ::LogicalNetlist::Netlist::PropertyMap>&& value);
  inline ::capnp::Orphan< ::LogicalNetlist::Netlist::PropertyMap> disownPropMap();

  inline bool hasStrList();
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder getStrList();
  inline void setStrList( ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader value);
  inline void setStrList(::kj::ArrayPtr<const  ::capnp::Text::Reader> value);
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder initStrList(unsigned int size);
  inline void adoptStrList(::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>> disownStrList();

  inline bool hasPortList();
  inline  ::capnp::List< ::LogicalNetlist::Netlist::Port,  ::capnp::Kind::STRUCT>::Builder getPortList();
  inline void setPortList( ::capnp::List< ::LogicalNetlist::Netlist::Port,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::LogicalNetlist::Netlist::Port,  ::capnp::Kind::STRUCT>::Builder initPortList(unsigned int size);
  inline void adoptPortList(::capnp::Orphan< ::capnp::List< ::LogicalNetlist::Netlist::Port,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::LogicalNetlist::Netlist::Port,  ::capnp::Kind::STRUCT>> disownPortList();

  inline bool hasCellDecls();
  inline  ::capnp::List< ::LogicalNetlist::Netlist::CellDeclaration,  ::capnp::Kind::STRUCT>::Builder getCellDecls();
  inline void setCellDecls( ::capnp::List< ::LogicalNetlist::Netlist::CellDeclaration,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::LogicalNetlist::Netlist::CellDeclaration,  ::capnp::Kind::STRUCT>::Builder initCellDecls(unsigned int size);
  inline void adoptCellDecls(::capnp::Orphan< ::capnp::List< ::LogicalNetlist::Netlist::CellDeclaration,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::LogicalNetlist::Netlist::CellDeclaration,  ::capnp::Kind::STRUCT>> disownCellDecls();

  inline bool hasTopInst();
  inline  ::LogicalNetlist::Netlist::CellInstance::Builder getTopInst();
  inline void setTopInst( ::LogicalNetlist::Netlist::CellInstance::Reader value);
  inline  ::LogicalNetlist::Netlist::CellInstance::Builder initTopInst();
  inline void adoptTopInst(::capnp::Orphan< ::LogicalNetlist::Netlist::CellInstance>&& value);
  inline ::capnp::Orphan< ::LogicalNetlist::Netlist::CellInstance> disownTopInst();

  inline bool hasInstList();
  inline  ::capnp::List< ::LogicalNetlist::Netlist::CellInstance,  ::capnp::Kind::STRUCT>::Builder getInstList();
  inline void setInstList( ::capnp::List< ::LogicalNetlist::Netlist::CellInstance,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::LogicalNetlist::Netlist::CellInstance,  ::capnp::Kind::STRUCT>::Builder initInstList(unsigned int size);
  inline void adoptInstList(::capnp::Orphan< ::capnp::List< ::LogicalNetlist::Netlist::CellInstance,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::LogicalNetlist::Netlist::CellInstance,  ::capnp::Kind::STRUCT>> disownInstList();

  inline bool hasCellList();
  inline  ::capnp::List< ::LogicalNetlist::Netlist::Cell,  ::capnp::Kind::STRUCT>::Builder getCellList();
  inline void setCellList( ::capnp::List< ::LogicalNetlist::Netlist::Cell,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::LogicalNetlist::Netlist::Cell,  ::capnp::Kind::STRUCT>::Builder initCellList(unsigned int size);
  inline void adoptCellList(::capnp::Orphan< ::capnp::List< ::LogicalNetlist::Netlist::Cell,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::LogicalNetlist::Netlist::Cell,  ::capnp::Kind::STRUCT>> disownCellList();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Netlist::Pipeline {
public:
  typedef Netlist Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::LogicalNetlist::Netlist::PropertyMap::Pipeline getPropMap();
  inline  ::LogicalNetlist::Netlist::CellInstance::Pipeline getTopInst();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Netlist::CellDeclaration::Reader {
public:
  typedef CellDeclaration Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getName() const;

  inline bool hasPropMap() const;
  inline  ::LogicalNetlist::Netlist::PropertyMap::Reader getPropMap() const;

  inline  ::uint32_t getView() const;

  inline  ::uint32_t getLib() const;

  inline bool hasPorts() const;
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader getPorts() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Netlist::CellDeclaration::Builder {
public:
  typedef CellDeclaration Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getName();
  inline void setName( ::uint32_t value);

  inline bool hasPropMap();
  inline  ::LogicalNetlist::Netlist::PropertyMap::Builder getPropMap();
  inline void setPropMap( ::LogicalNetlist::Netlist::PropertyMap::Reader value);
  inline  ::LogicalNetlist::Netlist::PropertyMap::Builder initPropMap();
  inline void adoptPropMap(::capnp::Orphan< ::LogicalNetlist::Netlist::PropertyMap>&& value);
  inline ::capnp::Orphan< ::LogicalNetlist::Netlist::PropertyMap> disownPropMap();

  inline  ::uint32_t getView();
  inline void setView( ::uint32_t value);

  inline  ::uint32_t getLib();
  inline void setLib( ::uint32_t value);

  inline bool hasPorts();
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder getPorts();
  inline void setPorts( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setPorts(::kj::ArrayPtr<const  ::uint32_t> value);
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder initPorts(unsigned int size);
  inline void adoptPorts(::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> disownPorts();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Netlist::CellDeclaration::Pipeline {
public:
  typedef CellDeclaration Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::LogicalNetlist::Netlist::PropertyMap::Pipeline getPropMap();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Netlist::CellInstance::Reader {
public:
  typedef CellInstance Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getName() const;

  inline bool hasPropMap() const;
  inline  ::LogicalNetlist::Netlist::PropertyMap::Reader getPropMap() const;

  inline  ::uint32_t getView() const;

  inline  ::uint32_t getCell() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Netlist::CellInstance::Builder {
public:
  typedef CellInstance Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getName();
  inline void setName( ::uint32_t value);

  inline bool hasPropMap();
  inline  ::LogicalNetlist::Netlist::PropertyMap::Builder getPropMap();
  inline void setPropMap( ::LogicalNetlist::Netlist::PropertyMap::Reader value);
  inline  ::LogicalNetlist::Netlist::PropertyMap::Builder initPropMap();
  inline void adoptPropMap(::capnp::Orphan< ::LogicalNetlist::Netlist::PropertyMap>&& value);
  inline ::capnp::Orphan< ::LogicalNetlist::Netlist::PropertyMap> disownPropMap();

  inline  ::uint32_t getView();
  inline void setView( ::uint32_t value);

  inline  ::uint32_t getCell();
  inline void setCell( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Netlist::CellInstance::Pipeline {
public:
  typedef CellInstance Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::LogicalNetlist::Netlist::PropertyMap::Pipeline getPropMap();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Netlist::Cell::Reader {
public:
  typedef Cell Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getIndex() const;

  inline bool hasInsts() const;
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader getInsts() const;

  inline bool hasNets() const;
  inline  ::capnp::List< ::LogicalNetlist::Netlist::Net,  ::capnp::Kind::STRUCT>::Reader getNets() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Netlist::Cell::Builder {
public:
  typedef Cell Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getIndex();
  inline void setIndex( ::uint32_t value);

  inline bool hasInsts();
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder getInsts();
  inline void setInsts( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setInsts(::kj::ArrayPtr<const  ::uint32_t> value);
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder initInsts(unsigned int size);
  inline void adoptInsts(::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> disownInsts();

  inline bool hasNets();
  inline  ::capnp::List< ::LogicalNetlist::Netlist::Net,  ::capnp::Kind::STRUCT>::Builder getNets();
  inline void setNets( ::capnp::List< ::LogicalNetlist::Netlist::Net,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::LogicalNetlist::Netlist::Net,  ::capnp::Kind::STRUCT>::Builder initNets(unsigned int size);
  inline void adoptNets(::capnp::Orphan< ::capnp::List< ::LogicalNetlist::Netlist::Net,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::LogicalNetlist::Netlist::Net,  ::capnp::Kind::STRUCT>> disownNets();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Netlist::Cell::Pipeline {
public:
  typedef Cell Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Netlist::Net::Reader {
public:
  typedef Net Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getName() const;

  inline bool hasPropMap() const;
  inline  ::LogicalNetlist::Netlist::PropertyMap::Reader getPropMap() const;

  inline bool hasPortInsts() const;
  inline  ::capnp::List< ::LogicalNetlist::Netlist::PortInstance,  ::capnp::Kind::STRUCT>::Reader getPortInsts() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Netlist::Net::Builder {
public:
  typedef Net Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getName();
  inline void setName( ::uint32_t value);

  inline bool hasPropMap();
  inline  ::LogicalNetlist::Netlist::PropertyMap::Builder getPropMap();
  inline void setPropMap( ::LogicalNetlist::Netlist::PropertyMap::Reader value);
  inline  ::LogicalNetlist::Netlist::PropertyMap::Builder initPropMap();
  inline void adoptPropMap(::capnp::Orphan< ::LogicalNetlist::Netlist::PropertyMap>&& value);
  inline ::capnp::Orphan< ::LogicalNetlist::Netlist::PropertyMap> disownPropMap();

  inline bool hasPortInsts();
  inline  ::capnp::List< ::LogicalNetlist::Netlist::PortInstance,  ::capnp::Kind::STRUCT>::Builder getPortInsts();
  inline void setPortInsts( ::capnp::List< ::LogicalNetlist::Netlist::PortInstance,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::LogicalNetlist::Netlist::PortInstance,  ::capnp::Kind::STRUCT>::Builder initPortInsts(unsigned int size);
  inline void adoptPortInsts(::capnp::Orphan< ::capnp::List< ::LogicalNetlist::Netlist::PortInstance,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::LogicalNetlist::Netlist::PortInstance,  ::capnp::Kind::STRUCT>> disownPortInsts();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Netlist::Net::Pipeline {
public:
  typedef Net Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::LogicalNetlist::Netlist::PropertyMap::Pipeline getPropMap();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Netlist::Port::Reader {
public:
  typedef Port Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline  ::uint32_t getName() const;

  inline  ::LogicalNetlist::Netlist::Direction getDir() const;

  inline bool hasPropMap() const;
  inline  ::LogicalNetlist::Netlist::PropertyMap::Reader getPropMap() const;

  inline bool isBit() const;
  inline  ::capnp::Void getBit() const;

  inline bool isBus() const;
  inline bool hasBus() const;
  inline  ::LogicalNetlist::Netlist::Bus::Reader getBus() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Netlist::Port::Builder {
public:
  typedef Port Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline  ::uint32_t getName();
  inline void setName( ::uint32_t value);

  inline  ::LogicalNetlist::Netlist::Direction getDir();
  inline void setDir( ::LogicalNetlist::Netlist::Direction value);

  inline bool hasPropMap();
  inline  ::LogicalNetlist::Netlist::PropertyMap::Builder getPropMap();
  inline void setPropMap( ::LogicalNetlist::Netlist::PropertyMap::Reader value);
  inline  ::LogicalNetlist::Netlist::PropertyMap::Builder initPropMap();
  inline void adoptPropMap(::capnp::Orphan< ::LogicalNetlist::Netlist::PropertyMap>&& value);
  inline ::capnp::Orphan< ::LogicalNetlist::Netlist::PropertyMap> disownPropMap();

  inline bool isBit();
  inline  ::capnp::Void getBit();
  inline void setBit( ::capnp::Void value = ::capnp::VOID);

  inline bool isBus();
  inline bool hasBus();
  inline  ::LogicalNetlist::Netlist::Bus::Builder getBus();
  inline void setBus( ::LogicalNetlist::Netlist::Bus::Reader value);
  inline  ::LogicalNetlist::Netlist::Bus::Builder initBus();
  inline void adoptBus(::capnp::Orphan< ::LogicalNetlist::Netlist::Bus>&& value);
  inline ::capnp::Orphan< ::LogicalNetlist::Netlist::Bus> disownBus();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Netlist::Port::Pipeline {
public:
  typedef Port Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::LogicalNetlist::Netlist::PropertyMap::Pipeline getPropMap();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Netlist::Bus::Reader {
public:
  typedef Bus Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getBusStart() const;

  inline  ::uint32_t getBusEnd() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Netlist::Bus::Builder {
public:
  typedef Bus Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getBusStart();
  inline void setBusStart( ::uint32_t value);

  inline  ::uint32_t getBusEnd();
  inline void setBusEnd( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Netlist::Bus::Pipeline {
public:
  typedef Bus Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Netlist::PortInstance::Reader {
public:
  typedef PortInstance Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline  ::uint32_t getPort() const;

  inline typename BusIdx::Reader getBusIdx() const;

  inline bool isExtPort() const;
  inline  ::capnp::Void getExtPort() const;

  inline bool isInst() const;
  inline  ::uint32_t getInst() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Netlist::PortInstance::Builder {
public:
  typedef PortInstance Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline  ::uint32_t getPort();
  inline void setPort( ::uint32_t value);

  inline typename BusIdx::Builder getBusIdx();
  inline typename BusIdx::Builder initBusIdx();

  inline bool isExtPort();
  inline  ::capnp::Void getExtPort();
  inline void setExtPort( ::capnp::Void value = ::capnp::VOID);

  inline bool isInst();
  inline  ::uint32_t getInst();
  inline void setInst( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Netlist::PortInstance::Pipeline {
public:
  typedef PortInstance Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename BusIdx::Pipeline getBusIdx();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Netlist::PortInstance::BusIdx::Reader {
public:
  typedef BusIdx Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isSingleBit() const;
  inline  ::capnp::Void getSingleBit() const;

  inline bool isIdx() const;
  inline  ::uint32_t getIdx() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Netlist::PortInstance::BusIdx::Builder {
public:
  typedef BusIdx Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isSingleBit();
  inline  ::capnp::Void getSingleBit();
  inline void setSingleBit( ::capnp::Void value = ::capnp::VOID);

  inline bool isIdx();
  inline  ::uint32_t getIdx();
  inline void setIdx( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Netlist::PortInstance::BusIdx::Pipeline {
public:
  typedef BusIdx Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Netlist::Bitstring::Reader {
public:
  typedef Bitstring Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getWidth() const;

  inline bool hasData() const;
  inline  ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Netlist::Bitstring::Builder {
public:
  typedef Bitstring Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getWidth();
  inline void setWidth( ::uint32_t value);

  inline bool hasData();
  inline  ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Builder getData();
  inline void setData( ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setData(::kj::ArrayPtr<const  ::uint8_t> value);
  inline  ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Netlist::Bitstring::Pipeline {
public:
  typedef Bitstring Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Netlist::PropertyMap::Reader {
public:
  typedef PropertyMap Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasEntries() const;
  inline  ::capnp::List< ::LogicalNetlist::Netlist::PropertyMap::Entry,  ::capnp::Kind::STRUCT>::Reader getEntries() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Netlist::PropertyMap::Builder {
public:
  typedef PropertyMap Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasEntries();
  inline  ::capnp::List< ::LogicalNetlist::Netlist::PropertyMap::Entry,  ::capnp::Kind::STRUCT>::Builder getEntries();
  inline void setEntries( ::capnp::List< ::LogicalNetlist::Netlist::PropertyMap::Entry,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::LogicalNetlist::Netlist::PropertyMap::Entry,  ::capnp::Kind::STRUCT>::Builder initEntries(unsigned int size);
  inline void adoptEntries(::capnp::Orphan< ::capnp::List< ::LogicalNetlist::Netlist::PropertyMap::Entry,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::LogicalNetlist::Netlist::PropertyMap::Entry,  ::capnp::Kind::STRUCT>> disownEntries();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Netlist::PropertyMap::Pipeline {
public:
  typedef PropertyMap Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Netlist::PropertyMap::Entry::Reader {
public:
  typedef Entry Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline  ::uint32_t getKey() const;

  inline bool isTextValue() const;
  inline  ::uint32_t getTextValue() const;

  inline bool isIntValue() const;
  inline  ::int32_t getIntValue() const;

  inline bool isBoolValue() const;
  inline bool getBoolValue() const;

  inline bool isBitstringValue() const;
  inline bool hasBitstringValue() const;
  inline  ::LogicalNetlist::Netlist::Bitstring::Reader getBitstringValue() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Netlist::PropertyMap::Entry::Builder {
public:
  typedef Entry Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline  ::uint32_t getKey();
  inline void setKey( ::uint32_t value);

  inline bool isTextValue();
  inline  ::uint32_t getTextValue();
  inline void setTextValue( ::uint32_t value);

  inline bool isIntValue();
  inline  ::int32_t getIntValue();
  inline void setIntValue( ::int32_t value);

  inline bool isBoolValue();
  inline bool getBoolValue();
  inline void setBoolValue(bool value);

  inline bool isBitstringValue();
  inline bool hasBitstringValue();
  inline  ::LogicalNetlist::Netlist::Bitstring::Builder getBitstringValue();
  inline void setBitstringValue( ::LogicalNetlist::Netlist::Bitstring::Reader value);
  inline  ::LogicalNetlist::Netlist::Bitstring::Builder initBitstringValue();
  inline void adoptBitstringValue(::capnp::Orphan< ::LogicalNetlist::Netlist::Bitstring>&& value);
  inline ::capnp::Orphan< ::LogicalNetlist::Netlist::Bitstring> disownBitstringValue();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Netlist::PropertyMap::Entry::Pipeline {
public:
  typedef Entry Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline  ::ImplementationType HashSet::Reader::getType() const {
  return _reader.getDataField< ::ImplementationType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::ImplementationType HashSet::Builder::getType() {
  return _builder.getDataField< ::ImplementationType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void HashSet::Builder::setType( ::ImplementationType value) {
  _builder.setDataField< ::ImplementationType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool HashSet::Reader::getHide() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS, true);
}

inline bool HashSet::Builder::getHide() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS, true);
}
inline void HashSet::Builder::setHide(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS, value, true);
}

inline  ::ReferenceType StringRef::Reader::getType() const {
  return _reader.getDataField< ::ReferenceType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 1u);
}

inline  ::ReferenceType StringRef::Builder::getType() {
  return _builder.getDataField< ::ReferenceType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 1u);
}
inline void StringRef::Builder::setType( ::ReferenceType value) {
  _builder.setDataField< ::ReferenceType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value, 1u);
}

inline bool StringRef::Reader::hasField() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool StringRef::Builder::hasField() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader StringRef::Reader::getField() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_fe08a36900b7aef1 + 48, 7);
}
inline  ::capnp::Text::Builder StringRef::Builder::getField() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_fe08a36900b7aef1 + 48, 7);
}
inline void StringRef::Builder::setField( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder StringRef::Builder::initField(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void StringRef::Builder::adoptField(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> StringRef::Builder::disownField() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::ReferenceType PortRef::Reader::getType() const {
  return _reader.getDataField< ::ReferenceType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 2u);
}

inline  ::ReferenceType PortRef::Builder::getType() {
  return _builder.getDataField< ::ReferenceType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 2u);
}
inline void PortRef::Builder::setType( ::ReferenceType value) {
  _builder.setDataField< ::ReferenceType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value, 2u);
}

inline bool PortRef::Reader::hasField() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool PortRef::Builder::hasField() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader PortRef::Reader::getField() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_cebd5deb07a1e8d0 + 55, 8);
}
inline  ::capnp::Text::Builder PortRef::Builder::getField() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_cebd5deb07a1e8d0 + 55, 8);
}
inline void PortRef::Builder::setField( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder PortRef::Builder::initField(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void PortRef::Builder::adoptField(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> PortRef::Builder::disownField() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::int32_t PortRef::Reader::getDepth() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, 1);
}

inline  ::int32_t PortRef::Builder::getDepth() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, 1);
}
inline void PortRef::Builder::setDepth( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value, 1);
}

inline  ::ReferenceType CellRef::Reader::getType() const {
  return _reader.getDataField< ::ReferenceType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 2u);
}

inline  ::ReferenceType CellRef::Builder::getType() {
  return _builder.getDataField< ::ReferenceType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 2u);
}
inline void CellRef::Builder::setType( ::ReferenceType value) {
  _builder.setDataField< ::ReferenceType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value, 2u);
}

inline bool CellRef::Reader::hasField() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool CellRef::Builder::hasField() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader CellRef::Reader::getField() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_d5c073f0cfa35210 + 55, 9);
}
inline  ::capnp::Text::Builder CellRef::Builder::getField() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_d5c073f0cfa35210 + 55, 9);
}
inline void CellRef::Builder::setField( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder CellRef::Builder::initField(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void CellRef::Builder::adoptField(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> CellRef::Builder::disownField() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::int32_t CellRef::Reader::getDepth() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, 1);
}

inline  ::int32_t CellRef::Builder::getDepth() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, 1);
}
inline void CellRef::Builder::setDepth( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value, 1);
}

inline  ::ReferenceType InstRef::Reader::getType() const {
  return _reader.getDataField< ::ReferenceType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 2u);
}

inline  ::ReferenceType InstRef::Builder::getType() {
  return _builder.getDataField< ::ReferenceType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 2u);
}
inline void InstRef::Builder::setType( ::ReferenceType value) {
  _builder.setDataField< ::ReferenceType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value, 2u);
}

inline bool InstRef::Reader::hasField() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool InstRef::Builder::hasField() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader InstRef::Reader::getField() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_aba131b7aa3363af + 55, 8);
}
inline  ::capnp::Text::Builder InstRef::Builder::getField() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_aba131b7aa3363af + 55, 8);
}
inline void InstRef::Builder::setField( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder InstRef::Builder::initField(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void InstRef::Builder::adoptField(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> InstRef::Builder::disownField() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::int32_t InstRef::Reader::getDepth() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, 1);
}

inline  ::int32_t InstRef::Builder::getDepth() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, 1);
}
inline void InstRef::Builder::setDepth( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value, 1);
}

inline bool Netlist::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Netlist::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Netlist::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Netlist::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Netlist::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Netlist::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Netlist::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Netlist::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Netlist::Reader::hasPropMap() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Netlist::Builder::hasPropMap() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::LogicalNetlist::Netlist::PropertyMap::Reader Netlist::Reader::getPropMap() const {
  return ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::PropertyMap>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::LogicalNetlist::Netlist::PropertyMap::Builder Netlist::Builder::getPropMap() {
  return ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::PropertyMap>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::LogicalNetlist::Netlist::PropertyMap::Pipeline Netlist::Pipeline::getPropMap() {
  return  ::LogicalNetlist::Netlist::PropertyMap::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Netlist::Builder::setPropMap( ::LogicalNetlist::Netlist::PropertyMap::Reader value) {
  ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::PropertyMap>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::LogicalNetlist::Netlist::PropertyMap::Builder Netlist::Builder::initPropMap() {
  return ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::PropertyMap>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Netlist::Builder::adoptPropMap(
    ::capnp::Orphan< ::LogicalNetlist::Netlist::PropertyMap>&& value) {
  ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::PropertyMap>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::LogicalNetlist::Netlist::PropertyMap> Netlist::Builder::disownPropMap() {
  return ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::PropertyMap>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Netlist::Reader::hasStrList() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Netlist::Builder::hasStrList() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader Netlist::Reader::getStrList() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder Netlist::Builder::getStrList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Netlist::Builder::setStrList( ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline void Netlist::Builder::setStrList(::kj::ArrayPtr<const  ::capnp::Text::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder Netlist::Builder::initStrList(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void Netlist::Builder::adoptStrList(
    ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>> Netlist::Builder::disownStrList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Netlist::Reader::hasPortList() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Netlist::Builder::hasPortList() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::LogicalNetlist::Netlist::Port,  ::capnp::Kind::STRUCT>::Reader Netlist::Reader::getPortList() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LogicalNetlist::Netlist::Port,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::LogicalNetlist::Netlist::Port,  ::capnp::Kind::STRUCT>::Builder Netlist::Builder::getPortList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LogicalNetlist::Netlist::Port,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Netlist::Builder::setPortList( ::capnp::List< ::LogicalNetlist::Netlist::Port,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::LogicalNetlist::Netlist::Port,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::LogicalNetlist::Netlist::Port,  ::capnp::Kind::STRUCT>::Builder Netlist::Builder::initPortList(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LogicalNetlist::Netlist::Port,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void Netlist::Builder::adoptPortList(
    ::capnp::Orphan< ::capnp::List< ::LogicalNetlist::Netlist::Port,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::LogicalNetlist::Netlist::Port,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::LogicalNetlist::Netlist::Port,  ::capnp::Kind::STRUCT>> Netlist::Builder::disownPortList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LogicalNetlist::Netlist::Port,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool Netlist::Reader::hasCellDecls() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool Netlist::Builder::hasCellDecls() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::LogicalNetlist::Netlist::CellDeclaration,  ::capnp::Kind::STRUCT>::Reader Netlist::Reader::getCellDecls() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LogicalNetlist::Netlist::CellDeclaration,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::LogicalNetlist::Netlist::CellDeclaration,  ::capnp::Kind::STRUCT>::Builder Netlist::Builder::getCellDecls() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LogicalNetlist::Netlist::CellDeclaration,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void Netlist::Builder::setCellDecls( ::capnp::List< ::LogicalNetlist::Netlist::CellDeclaration,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::LogicalNetlist::Netlist::CellDeclaration,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::LogicalNetlist::Netlist::CellDeclaration,  ::capnp::Kind::STRUCT>::Builder Netlist::Builder::initCellDecls(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LogicalNetlist::Netlist::CellDeclaration,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), size);
}
inline void Netlist::Builder::adoptCellDecls(
    ::capnp::Orphan< ::capnp::List< ::LogicalNetlist::Netlist::CellDeclaration,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::LogicalNetlist::Netlist::CellDeclaration,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::LogicalNetlist::Netlist::CellDeclaration,  ::capnp::Kind::STRUCT>> Netlist::Builder::disownCellDecls() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LogicalNetlist::Netlist::CellDeclaration,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline bool Netlist::Reader::hasTopInst() const {
  return !_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline bool Netlist::Builder::hasTopInst() {
  return !_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline  ::LogicalNetlist::Netlist::CellInstance::Reader Netlist::Reader::getTopInst() const {
  return ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::CellInstance>::get(_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline  ::LogicalNetlist::Netlist::CellInstance::Builder Netlist::Builder::getTopInst() {
  return ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::CellInstance>::get(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::LogicalNetlist::Netlist::CellInstance::Pipeline Netlist::Pipeline::getTopInst() {
  return  ::LogicalNetlist::Netlist::CellInstance::Pipeline(_typeless.getPointerField(5));
}
#endif  // !CAPNP_LITE
inline void Netlist::Builder::setTopInst( ::LogicalNetlist::Netlist::CellInstance::Reader value) {
  ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::CellInstance>::set(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), value);
}
inline  ::LogicalNetlist::Netlist::CellInstance::Builder Netlist::Builder::initTopInst() {
  return ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::CellInstance>::init(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline void Netlist::Builder::adoptTopInst(
    ::capnp::Orphan< ::LogicalNetlist::Netlist::CellInstance>&& value) {
  ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::CellInstance>::adopt(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::LogicalNetlist::Netlist::CellInstance> Netlist::Builder::disownTopInst() {
  return ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::CellInstance>::disown(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}

inline bool Netlist::Reader::hasInstList() const {
  return !_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline bool Netlist::Builder::hasInstList() {
  return !_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::LogicalNetlist::Netlist::CellInstance,  ::capnp::Kind::STRUCT>::Reader Netlist::Reader::getInstList() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LogicalNetlist::Netlist::CellInstance,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::LogicalNetlist::Netlist::CellInstance,  ::capnp::Kind::STRUCT>::Builder Netlist::Builder::getInstList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LogicalNetlist::Netlist::CellInstance,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline void Netlist::Builder::setInstList( ::capnp::List< ::LogicalNetlist::Netlist::CellInstance,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::LogicalNetlist::Netlist::CellInstance,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::LogicalNetlist::Netlist::CellInstance,  ::capnp::Kind::STRUCT>::Builder Netlist::Builder::initInstList(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LogicalNetlist::Netlist::CellInstance,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), size);
}
inline void Netlist::Builder::adoptInstList(
    ::capnp::Orphan< ::capnp::List< ::LogicalNetlist::Netlist::CellInstance,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::LogicalNetlist::Netlist::CellInstance,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::LogicalNetlist::Netlist::CellInstance,  ::capnp::Kind::STRUCT>> Netlist::Builder::disownInstList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LogicalNetlist::Netlist::CellInstance,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}

inline bool Netlist::Reader::hasCellList() const {
  return !_reader.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS).isNull();
}
inline bool Netlist::Builder::hasCellList() {
  return !_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::LogicalNetlist::Netlist::Cell,  ::capnp::Kind::STRUCT>::Reader Netlist::Reader::getCellList() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LogicalNetlist::Netlist::Cell,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::LogicalNetlist::Netlist::Cell,  ::capnp::Kind::STRUCT>::Builder Netlist::Builder::getCellList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LogicalNetlist::Netlist::Cell,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
inline void Netlist::Builder::setCellList( ::capnp::List< ::LogicalNetlist::Netlist::Cell,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::LogicalNetlist::Netlist::Cell,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::LogicalNetlist::Netlist::Cell,  ::capnp::Kind::STRUCT>::Builder Netlist::Builder::initCellList(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LogicalNetlist::Netlist::Cell,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), size);
}
inline void Netlist::Builder::adoptCellList(
    ::capnp::Orphan< ::capnp::List< ::LogicalNetlist::Netlist::Cell,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::LogicalNetlist::Netlist::Cell,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::LogicalNetlist::Netlist::Cell,  ::capnp::Kind::STRUCT>> Netlist::Builder::disownCellList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LogicalNetlist::Netlist::Cell,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}

inline  ::uint32_t Netlist::CellDeclaration::Reader::getName() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Netlist::CellDeclaration::Builder::getName() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Netlist::CellDeclaration::Builder::setName( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Netlist::CellDeclaration::Reader::hasPropMap() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Netlist::CellDeclaration::Builder::hasPropMap() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::LogicalNetlist::Netlist::PropertyMap::Reader Netlist::CellDeclaration::Reader::getPropMap() const {
  return ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::PropertyMap>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::LogicalNetlist::Netlist::PropertyMap::Builder Netlist::CellDeclaration::Builder::getPropMap() {
  return ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::PropertyMap>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::LogicalNetlist::Netlist::PropertyMap::Pipeline Netlist::CellDeclaration::Pipeline::getPropMap() {
  return  ::LogicalNetlist::Netlist::PropertyMap::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Netlist::CellDeclaration::Builder::setPropMap( ::LogicalNetlist::Netlist::PropertyMap::Reader value) {
  ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::PropertyMap>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::LogicalNetlist::Netlist::PropertyMap::Builder Netlist::CellDeclaration::Builder::initPropMap() {
  return ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::PropertyMap>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Netlist::CellDeclaration::Builder::adoptPropMap(
    ::capnp::Orphan< ::LogicalNetlist::Netlist::PropertyMap>&& value) {
  ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::PropertyMap>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::LogicalNetlist::Netlist::PropertyMap> Netlist::CellDeclaration::Builder::disownPropMap() {
  return ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::PropertyMap>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t Netlist::CellDeclaration::Reader::getView() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Netlist::CellDeclaration::Builder::getView() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Netlist::CellDeclaration::Builder::setView( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Netlist::CellDeclaration::Reader::getLib() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Netlist::CellDeclaration::Builder::getLib() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Netlist::CellDeclaration::Builder::setLib( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool Netlist::CellDeclaration::Reader::hasPorts() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Netlist::CellDeclaration::Builder::hasPorts() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader Netlist::CellDeclaration::Reader::getPorts() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder Netlist::CellDeclaration::Builder::getPorts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Netlist::CellDeclaration::Builder::setPorts( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void Netlist::CellDeclaration::Builder::setPorts(::kj::ArrayPtr<const  ::uint32_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder Netlist::CellDeclaration::Builder::initPorts(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Netlist::CellDeclaration::Builder::adoptPorts(
    ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> Netlist::CellDeclaration::Builder::disownPorts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::uint32_t Netlist::CellInstance::Reader::getName() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Netlist::CellInstance::Builder::getName() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Netlist::CellInstance::Builder::setName( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Netlist::CellInstance::Reader::hasPropMap() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Netlist::CellInstance::Builder::hasPropMap() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::LogicalNetlist::Netlist::PropertyMap::Reader Netlist::CellInstance::Reader::getPropMap() const {
  return ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::PropertyMap>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::LogicalNetlist::Netlist::PropertyMap::Builder Netlist::CellInstance::Builder::getPropMap() {
  return ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::PropertyMap>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::LogicalNetlist::Netlist::PropertyMap::Pipeline Netlist::CellInstance::Pipeline::getPropMap() {
  return  ::LogicalNetlist::Netlist::PropertyMap::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Netlist::CellInstance::Builder::setPropMap( ::LogicalNetlist::Netlist::PropertyMap::Reader value) {
  ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::PropertyMap>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::LogicalNetlist::Netlist::PropertyMap::Builder Netlist::CellInstance::Builder::initPropMap() {
  return ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::PropertyMap>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Netlist::CellInstance::Builder::adoptPropMap(
    ::capnp::Orphan< ::LogicalNetlist::Netlist::PropertyMap>&& value) {
  ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::PropertyMap>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::LogicalNetlist::Netlist::PropertyMap> Netlist::CellInstance::Builder::disownPropMap() {
  return ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::PropertyMap>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t Netlist::CellInstance::Reader::getView() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Netlist::CellInstance::Builder::getView() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Netlist::CellInstance::Builder::setView( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Netlist::CellInstance::Reader::getCell() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Netlist::CellInstance::Builder::getCell() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Netlist::CellInstance::Builder::setCell( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Netlist::Cell::Reader::getIndex() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Netlist::Cell::Builder::getIndex() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Netlist::Cell::Builder::setIndex( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Netlist::Cell::Reader::hasInsts() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Netlist::Cell::Builder::hasInsts() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader Netlist::Cell::Reader::getInsts() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder Netlist::Cell::Builder::getInsts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Netlist::Cell::Builder::setInsts( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void Netlist::Cell::Builder::setInsts(::kj::ArrayPtr<const  ::uint32_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder Netlist::Cell::Builder::initInsts(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Netlist::Cell::Builder::adoptInsts(
    ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> Netlist::Cell::Builder::disownInsts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Netlist::Cell::Reader::hasNets() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Netlist::Cell::Builder::hasNets() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::LogicalNetlist::Netlist::Net,  ::capnp::Kind::STRUCT>::Reader Netlist::Cell::Reader::getNets() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LogicalNetlist::Netlist::Net,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::LogicalNetlist::Netlist::Net,  ::capnp::Kind::STRUCT>::Builder Netlist::Cell::Builder::getNets() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LogicalNetlist::Netlist::Net,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Netlist::Cell::Builder::setNets( ::capnp::List< ::LogicalNetlist::Netlist::Net,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::LogicalNetlist::Netlist::Net,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::LogicalNetlist::Netlist::Net,  ::capnp::Kind::STRUCT>::Builder Netlist::Cell::Builder::initNets(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LogicalNetlist::Netlist::Net,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Netlist::Cell::Builder::adoptNets(
    ::capnp::Orphan< ::capnp::List< ::LogicalNetlist::Netlist::Net,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::LogicalNetlist::Netlist::Net,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::LogicalNetlist::Netlist::Net,  ::capnp::Kind::STRUCT>> Netlist::Cell::Builder::disownNets() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LogicalNetlist::Netlist::Net,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::uint32_t Netlist::Net::Reader::getName() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Netlist::Net::Builder::getName() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Netlist::Net::Builder::setName( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Netlist::Net::Reader::hasPropMap() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Netlist::Net::Builder::hasPropMap() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::LogicalNetlist::Netlist::PropertyMap::Reader Netlist::Net::Reader::getPropMap() const {
  return ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::PropertyMap>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::LogicalNetlist::Netlist::PropertyMap::Builder Netlist::Net::Builder::getPropMap() {
  return ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::PropertyMap>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::LogicalNetlist::Netlist::PropertyMap::Pipeline Netlist::Net::Pipeline::getPropMap() {
  return  ::LogicalNetlist::Netlist::PropertyMap::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Netlist::Net::Builder::setPropMap( ::LogicalNetlist::Netlist::PropertyMap::Reader value) {
  ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::PropertyMap>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::LogicalNetlist::Netlist::PropertyMap::Builder Netlist::Net::Builder::initPropMap() {
  return ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::PropertyMap>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Netlist::Net::Builder::adoptPropMap(
    ::capnp::Orphan< ::LogicalNetlist::Netlist::PropertyMap>&& value) {
  ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::PropertyMap>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::LogicalNetlist::Netlist::PropertyMap> Netlist::Net::Builder::disownPropMap() {
  return ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::PropertyMap>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Netlist::Net::Reader::hasPortInsts() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Netlist::Net::Builder::hasPortInsts() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::LogicalNetlist::Netlist::PortInstance,  ::capnp::Kind::STRUCT>::Reader Netlist::Net::Reader::getPortInsts() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LogicalNetlist::Netlist::PortInstance,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::LogicalNetlist::Netlist::PortInstance,  ::capnp::Kind::STRUCT>::Builder Netlist::Net::Builder::getPortInsts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LogicalNetlist::Netlist::PortInstance,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Netlist::Net::Builder::setPortInsts( ::capnp::List< ::LogicalNetlist::Netlist::PortInstance,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::LogicalNetlist::Netlist::PortInstance,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::LogicalNetlist::Netlist::PortInstance,  ::capnp::Kind::STRUCT>::Builder Netlist::Net::Builder::initPortInsts(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LogicalNetlist::Netlist::PortInstance,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Netlist::Net::Builder::adoptPortInsts(
    ::capnp::Orphan< ::capnp::List< ::LogicalNetlist::Netlist::PortInstance,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::LogicalNetlist::Netlist::PortInstance,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::LogicalNetlist::Netlist::PortInstance,  ::capnp::Kind::STRUCT>> Netlist::Net::Builder::disownPortInsts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LogicalNetlist::Netlist::PortInstance,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::LogicalNetlist::Netlist::Port::Which Netlist::Port::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline  ::LogicalNetlist::Netlist::Port::Which Netlist::Port::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Netlist::Port::Reader::getName() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Netlist::Port::Builder::getName() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Netlist::Port::Builder::setName( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::LogicalNetlist::Netlist::Direction Netlist::Port::Reader::getDir() const {
  return _reader.getDataField< ::LogicalNetlist::Netlist::Direction>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::LogicalNetlist::Netlist::Direction Netlist::Port::Builder::getDir() {
  return _builder.getDataField< ::LogicalNetlist::Netlist::Direction>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Netlist::Port::Builder::setDir( ::LogicalNetlist::Netlist::Direction value) {
  _builder.setDataField< ::LogicalNetlist::Netlist::Direction>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool Netlist::Port::Reader::hasPropMap() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Netlist::Port::Builder::hasPropMap() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::LogicalNetlist::Netlist::PropertyMap::Reader Netlist::Port::Reader::getPropMap() const {
  return ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::PropertyMap>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::LogicalNetlist::Netlist::PropertyMap::Builder Netlist::Port::Builder::getPropMap() {
  return ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::PropertyMap>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::LogicalNetlist::Netlist::PropertyMap::Pipeline Netlist::Port::Pipeline::getPropMap() {
  return  ::LogicalNetlist::Netlist::PropertyMap::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Netlist::Port::Builder::setPropMap( ::LogicalNetlist::Netlist::PropertyMap::Reader value) {
  ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::PropertyMap>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::LogicalNetlist::Netlist::PropertyMap::Builder Netlist::Port::Builder::initPropMap() {
  return ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::PropertyMap>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Netlist::Port::Builder::adoptPropMap(
    ::capnp::Orphan< ::LogicalNetlist::Netlist::PropertyMap>&& value) {
  ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::PropertyMap>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::LogicalNetlist::Netlist::PropertyMap> Netlist::Port::Builder::disownPropMap() {
  return ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::PropertyMap>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Netlist::Port::Reader::isBit() const {
  return which() == Netlist::Port::BIT;
}
inline bool Netlist::Port::Builder::isBit() {
  return which() == Netlist::Port::BIT;
}
inline  ::capnp::Void Netlist::Port::Reader::getBit() const {
  KJ_IREQUIRE((which() == Netlist::Port::BIT),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Netlist::Port::Builder::getBit() {
  KJ_IREQUIRE((which() == Netlist::Port::BIT),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Netlist::Port::Builder::setBit( ::capnp::Void value) {
  _builder.setDataField<Netlist::Port::Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, Netlist::Port::BIT);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Netlist::Port::Reader::isBus() const {
  return which() == Netlist::Port::BUS;
}
inline bool Netlist::Port::Builder::isBus() {
  return which() == Netlist::Port::BUS;
}
inline bool Netlist::Port::Reader::hasBus() const {
  if (which() != Netlist::Port::BUS) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Netlist::Port::Builder::hasBus() {
  if (which() != Netlist::Port::BUS) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::LogicalNetlist::Netlist::Bus::Reader Netlist::Port::Reader::getBus() const {
  KJ_IREQUIRE((which() == Netlist::Port::BUS),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::Bus>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::LogicalNetlist::Netlist::Bus::Builder Netlist::Port::Builder::getBus() {
  KJ_IREQUIRE((which() == Netlist::Port::BUS),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::Bus>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Netlist::Port::Builder::setBus( ::LogicalNetlist::Netlist::Bus::Reader value) {
  _builder.setDataField<Netlist::Port::Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, Netlist::Port::BUS);
  ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::Bus>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::LogicalNetlist::Netlist::Bus::Builder Netlist::Port::Builder::initBus() {
  _builder.setDataField<Netlist::Port::Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, Netlist::Port::BUS);
  return ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::Bus>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Netlist::Port::Builder::adoptBus(
    ::capnp::Orphan< ::LogicalNetlist::Netlist::Bus>&& value) {
  _builder.setDataField<Netlist::Port::Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, Netlist::Port::BUS);
  ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::Bus>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::LogicalNetlist::Netlist::Bus> Netlist::Port::Builder::disownBus() {
  KJ_IREQUIRE((which() == Netlist::Port::BUS),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::Bus>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::uint32_t Netlist::Bus::Reader::getBusStart() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Netlist::Bus::Builder::getBusStart() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Netlist::Bus::Builder::setBusStart( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Netlist::Bus::Reader::getBusEnd() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Netlist::Bus::Builder::getBusEnd() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Netlist::Bus::Builder::setBusEnd( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::LogicalNetlist::Netlist::PortInstance::Which Netlist::PortInstance::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline  ::LogicalNetlist::Netlist::PortInstance::Which Netlist::PortInstance::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Netlist::PortInstance::Reader::getPort() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Netlist::PortInstance::Builder::getPort() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Netlist::PortInstance::Builder::setPort( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline typename Netlist::PortInstance::BusIdx::Reader Netlist::PortInstance::Reader::getBusIdx() const {
  return typename Netlist::PortInstance::BusIdx::Reader(_reader);
}
inline typename Netlist::PortInstance::BusIdx::Builder Netlist::PortInstance::Builder::getBusIdx() {
  return typename Netlist::PortInstance::BusIdx::Builder(_builder);
}
#if !CAPNP_LITE
inline typename Netlist::PortInstance::BusIdx::Pipeline Netlist::PortInstance::Pipeline::getBusIdx() {
  return typename Netlist::PortInstance::BusIdx::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline typename Netlist::PortInstance::BusIdx::Builder Netlist::PortInstance::Builder::initBusIdx() {
  _builder.setDataField< ::uint16_t>(::capnp::bounded<2>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint32_t>(::capnp::bounded<2>() * ::capnp::ELEMENTS, 0);
  return typename Netlist::PortInstance::BusIdx::Builder(_builder);
}
inline bool Netlist::PortInstance::Reader::isExtPort() const {
  return which() == Netlist::PortInstance::EXT_PORT;
}
inline bool Netlist::PortInstance::Builder::isExtPort() {
  return which() == Netlist::PortInstance::EXT_PORT;
}
inline  ::capnp::Void Netlist::PortInstance::Reader::getExtPort() const {
  KJ_IREQUIRE((which() == Netlist::PortInstance::EXT_PORT),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Netlist::PortInstance::Builder::getExtPort() {
  KJ_IREQUIRE((which() == Netlist::PortInstance::EXT_PORT),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Netlist::PortInstance::Builder::setExtPort( ::capnp::Void value) {
  _builder.setDataField<Netlist::PortInstance::Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, Netlist::PortInstance::EXT_PORT);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Netlist::PortInstance::Reader::isInst() const {
  return which() == Netlist::PortInstance::INST;
}
inline bool Netlist::PortInstance::Builder::isInst() {
  return which() == Netlist::PortInstance::INST;
}
inline  ::uint32_t Netlist::PortInstance::Reader::getInst() const {
  KJ_IREQUIRE((which() == Netlist::PortInstance::INST),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Netlist::PortInstance::Builder::getInst() {
  KJ_IREQUIRE((which() == Netlist::PortInstance::INST),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void Netlist::PortInstance::Builder::setInst( ::uint32_t value) {
  _builder.setDataField<Netlist::PortInstance::Which>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, Netlist::PortInstance::INST);
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline  ::LogicalNetlist::Netlist::PortInstance::BusIdx::Which Netlist::PortInstance::BusIdx::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline  ::LogicalNetlist::Netlist::PortInstance::BusIdx::Which Netlist::PortInstance::BusIdx::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline bool Netlist::PortInstance::BusIdx::Reader::isSingleBit() const {
  return which() == Netlist::PortInstance::BusIdx::SINGLE_BIT;
}
inline bool Netlist::PortInstance::BusIdx::Builder::isSingleBit() {
  return which() == Netlist::PortInstance::BusIdx::SINGLE_BIT;
}
inline  ::capnp::Void Netlist::PortInstance::BusIdx::Reader::getSingleBit() const {
  KJ_IREQUIRE((which() == Netlist::PortInstance::BusIdx::SINGLE_BIT),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Netlist::PortInstance::BusIdx::Builder::getSingleBit() {
  KJ_IREQUIRE((which() == Netlist::PortInstance::BusIdx::SINGLE_BIT),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Netlist::PortInstance::BusIdx::Builder::setSingleBit( ::capnp::Void value) {
  _builder.setDataField<Netlist::PortInstance::BusIdx::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Netlist::PortInstance::BusIdx::SINGLE_BIT);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Netlist::PortInstance::BusIdx::Reader::isIdx() const {
  return which() == Netlist::PortInstance::BusIdx::IDX;
}
inline bool Netlist::PortInstance::BusIdx::Builder::isIdx() {
  return which() == Netlist::PortInstance::BusIdx::IDX;
}
inline  ::uint32_t Netlist::PortInstance::BusIdx::Reader::getIdx() const {
  KJ_IREQUIRE((which() == Netlist::PortInstance::BusIdx::IDX),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Netlist::PortInstance::BusIdx::Builder::getIdx() {
  KJ_IREQUIRE((which() == Netlist::PortInstance::BusIdx::IDX),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Netlist::PortInstance::BusIdx::Builder::setIdx( ::uint32_t value) {
  _builder.setDataField<Netlist::PortInstance::BusIdx::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Netlist::PortInstance::BusIdx::IDX);
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Netlist::Bitstring::Reader::getWidth() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Netlist::Bitstring::Builder::getWidth() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Netlist::Bitstring::Builder::setWidth( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Netlist::Bitstring::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Netlist::Bitstring::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Reader Netlist::Bitstring::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Builder Netlist::Bitstring::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Netlist::Bitstring::Builder::setData( ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void Netlist::Bitstring::Builder::setData(::kj::ArrayPtr<const  ::uint8_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Builder Netlist::Bitstring::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Netlist::Bitstring::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>> Netlist::Bitstring::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Netlist::PropertyMap::Reader::hasEntries() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Netlist::PropertyMap::Builder::hasEntries() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::LogicalNetlist::Netlist::PropertyMap::Entry,  ::capnp::Kind::STRUCT>::Reader Netlist::PropertyMap::Reader::getEntries() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LogicalNetlist::Netlist::PropertyMap::Entry,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::LogicalNetlist::Netlist::PropertyMap::Entry,  ::capnp::Kind::STRUCT>::Builder Netlist::PropertyMap::Builder::getEntries() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LogicalNetlist::Netlist::PropertyMap::Entry,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Netlist::PropertyMap::Builder::setEntries( ::capnp::List< ::LogicalNetlist::Netlist::PropertyMap::Entry,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::LogicalNetlist::Netlist::PropertyMap::Entry,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::LogicalNetlist::Netlist::PropertyMap::Entry,  ::capnp::Kind::STRUCT>::Builder Netlist::PropertyMap::Builder::initEntries(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LogicalNetlist::Netlist::PropertyMap::Entry,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Netlist::PropertyMap::Builder::adoptEntries(
    ::capnp::Orphan< ::capnp::List< ::LogicalNetlist::Netlist::PropertyMap::Entry,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::LogicalNetlist::Netlist::PropertyMap::Entry,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::LogicalNetlist::Netlist::PropertyMap::Entry,  ::capnp::Kind::STRUCT>> Netlist::PropertyMap::Builder::disownEntries() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::LogicalNetlist::Netlist::PropertyMap::Entry,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::LogicalNetlist::Netlist::PropertyMap::Entry::Which Netlist::PropertyMap::Entry::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline  ::LogicalNetlist::Netlist::PropertyMap::Entry::Which Netlist::PropertyMap::Entry::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Netlist::PropertyMap::Entry::Reader::getKey() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Netlist::PropertyMap::Entry::Builder::getKey() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Netlist::PropertyMap::Entry::Builder::setKey( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Netlist::PropertyMap::Entry::Reader::isTextValue() const {
  return which() == Netlist::PropertyMap::Entry::TEXT_VALUE;
}
inline bool Netlist::PropertyMap::Entry::Builder::isTextValue() {
  return which() == Netlist::PropertyMap::Entry::TEXT_VALUE;
}
inline  ::uint32_t Netlist::PropertyMap::Entry::Reader::getTextValue() const {
  KJ_IREQUIRE((which() == Netlist::PropertyMap::Entry::TEXT_VALUE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Netlist::PropertyMap::Entry::Builder::getTextValue() {
  KJ_IREQUIRE((which() == Netlist::PropertyMap::Entry::TEXT_VALUE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Netlist::PropertyMap::Entry::Builder::setTextValue( ::uint32_t value) {
  _builder.setDataField<Netlist::PropertyMap::Entry::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Netlist::PropertyMap::Entry::TEXT_VALUE);
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Netlist::PropertyMap::Entry::Reader::isIntValue() const {
  return which() == Netlist::PropertyMap::Entry::INT_VALUE;
}
inline bool Netlist::PropertyMap::Entry::Builder::isIntValue() {
  return which() == Netlist::PropertyMap::Entry::INT_VALUE;
}
inline  ::int32_t Netlist::PropertyMap::Entry::Reader::getIntValue() const {
  KJ_IREQUIRE((which() == Netlist::PropertyMap::Entry::INT_VALUE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int32_t Netlist::PropertyMap::Entry::Builder::getIntValue() {
  KJ_IREQUIRE((which() == Netlist::PropertyMap::Entry::INT_VALUE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Netlist::PropertyMap::Entry::Builder::setIntValue( ::int32_t value) {
  _builder.setDataField<Netlist::PropertyMap::Entry::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Netlist::PropertyMap::Entry::INT_VALUE);
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Netlist::PropertyMap::Entry::Reader::isBoolValue() const {
  return which() == Netlist::PropertyMap::Entry::BOOL_VALUE;
}
inline bool Netlist::PropertyMap::Entry::Builder::isBoolValue() {
  return which() == Netlist::PropertyMap::Entry::BOOL_VALUE;
}
inline bool Netlist::PropertyMap::Entry::Reader::getBoolValue() const {
  KJ_IREQUIRE((which() == Netlist::PropertyMap::Entry::BOOL_VALUE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<bool>(
      ::capnp::bounded<32>() * ::capnp::ELEMENTS);
}

inline bool Netlist::PropertyMap::Entry::Builder::getBoolValue() {
  KJ_IREQUIRE((which() == Netlist::PropertyMap::Entry::BOOL_VALUE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<bool>(
      ::capnp::bounded<32>() * ::capnp::ELEMENTS);
}
inline void Netlist::PropertyMap::Entry::Builder::setBoolValue(bool value) {
  _builder.setDataField<Netlist::PropertyMap::Entry::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Netlist::PropertyMap::Entry::BOOL_VALUE);
  _builder.setDataField<bool>(
      ::capnp::bounded<32>() * ::capnp::ELEMENTS, value);
}

inline bool Netlist::PropertyMap::Entry::Reader::isBitstringValue() const {
  return which() == Netlist::PropertyMap::Entry::BITSTRING_VALUE;
}
inline bool Netlist::PropertyMap::Entry::Builder::isBitstringValue() {
  return which() == Netlist::PropertyMap::Entry::BITSTRING_VALUE;
}
inline bool Netlist::PropertyMap::Entry::Reader::hasBitstringValue() const {
  if (which() != Netlist::PropertyMap::Entry::BITSTRING_VALUE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Netlist::PropertyMap::Entry::Builder::hasBitstringValue() {
  if (which() != Netlist::PropertyMap::Entry::BITSTRING_VALUE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::LogicalNetlist::Netlist::Bitstring::Reader Netlist::PropertyMap::Entry::Reader::getBitstringValue() const {
  KJ_IREQUIRE((which() == Netlist::PropertyMap::Entry::BITSTRING_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::Bitstring>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::LogicalNetlist::Netlist::Bitstring::Builder Netlist::PropertyMap::Entry::Builder::getBitstringValue() {
  KJ_IREQUIRE((which() == Netlist::PropertyMap::Entry::BITSTRING_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::Bitstring>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Netlist::PropertyMap::Entry::Builder::setBitstringValue( ::LogicalNetlist::Netlist::Bitstring::Reader value) {
  _builder.setDataField<Netlist::PropertyMap::Entry::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Netlist::PropertyMap::Entry::BITSTRING_VALUE);
  ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::Bitstring>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::LogicalNetlist::Netlist::Bitstring::Builder Netlist::PropertyMap::Entry::Builder::initBitstringValue() {
  _builder.setDataField<Netlist::PropertyMap::Entry::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Netlist::PropertyMap::Entry::BITSTRING_VALUE);
  return ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::Bitstring>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Netlist::PropertyMap::Entry::Builder::adoptBitstringValue(
    ::capnp::Orphan< ::LogicalNetlist::Netlist::Bitstring>&& value) {
  _builder.setDataField<Netlist::PropertyMap::Entry::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Netlist::PropertyMap::Entry::BITSTRING_VALUE);
  ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::Bitstring>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::LogicalNetlist::Netlist::Bitstring> Netlist::PropertyMap::Entry::Builder::disownBitstringValue() {
  KJ_IREQUIRE((which() == Netlist::PropertyMap::Entry::BITSTRING_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::LogicalNetlist::Netlist::Bitstring>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

}  // namespace

CAPNP_END_HEADER

